//
// Created by franc on 5/31/2025.
//

#pragma once
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <unistd.h>
#include <random>
#include "Define.h"
#include "State.h"

// Create the random engine and distribution ONCE (global or inside a class)
inline std::random_device rd;
inline std::mt19937 m_gen(rd());
inline std::uniform_real_distribution<> m_dis(0.0, 1.0);

template <StateRepresentation StateRepr>
class GraphNN {

public:

    [[nodiscard]]bool generate_dataset();
    void create_instance();


private:

    GraphNN();


    static GraphNN* instance; ///< Singleton instance

    std::string m_dataset_folder = OutputPaths::GNN_OUTPUT_FOLDER + "/Datasets/";
    std::string m_filepath = "";
    std::string m_raw_folder = "";
    std::string m_goal_file_path = "";

    unsigned long m_file_counter = 0;

    std::unordered_map<Fluent, size_t> m_fluent_to_id;
    std::unordered_map<Agent, size_t> m_agent_to_id;

    size_t m_current_nodes = 0;
    size_t m_threshold_node_generation = 50000; //Actual value of final nodes no matter what
    double m_threshold_node_generation_log = std::log(m_threshold_node_generation*3); // times 3 to allow for some room given the action executability as this is just use as criteron on what start proabilistics prune
    size_t m_total_possible_nodes_log = 0; //Possible nodes generated by the complete DFS
    bool m_goal_recently_found = false;
    double m_discard_augmentation_factor = 0; // Tracks augmentation for non-discarded paths
    size_t m_goal_founds = 0;

    std::unordered_set<State<StateRepr>> m_visited_states;
    std::unordered_map<State<StateRepr>,int> m_states_scores;

    static size_t get_id_from_map(const std::unordered_map<boost::dynamic_bitset<>, size_t>& id_map,
                                  const boost::dynamic_bitset<>& key,
                                  const std::string& type_name);

    static void populate_ids_from_bitset(const std::set<boost::dynamic_bitset<>>& keys_set,
                                         std::unordered_map<boost::dynamic_bitset<>, size_t>& id_map,
                                         size_t start_id);

    size_t get_unique_f_id_from_map(const Fluent &fl) const;
    size_t get_unique_a_id_from_map(const Agent &ag) const;

    void populate_fluent_ids(size_t start_id);
    void populate_agent_ids(size_t start_id);

    void generate_goal_tree();

    void print_goal_subtree(const BeliefFormula& to_print, size_t goal_counter, size_t& next_id,
                            const std::string& parent_node, std::ofstream&);

    bool search_space_exploration(std::ostream &os);

    bool dfs_exploration(State<StateRepr> &initial_state, ActionsSet *actions,
                         std::vector<std::string> &global_dataset, std::ostream &os);

    int dfs_worker(State<StateRepr> &state, size_t depth, ActionsSet *actions,
                   std::vector<std::string> &global_dataset);

    std::string format_row(State<StateRepr> &state, size_t depth, int score);
};


/*
/** Mutex for protecting global ML dataset. #1#

std::map<T,int> m_states_scores;

/*Make this a struct maybe#1#
int m_threshold_node_generation = 50000; //Actual value of final nodes no matter what
double m_threshold_node_generation_log = std::log(m_threshold_node_generation*3); // times 3 to allow for some room given the action executability as this is just use as criteron on what start proabilistics prune
int m_total_possible_nodes_log; //Possible nodes generated by the complete DFS
bool m_goal_recently_found = false;
double m_discard_augmentation_factor = 0; // Tracks augmentation for non-discarded paths
int m_goal_founds = 0;


/*     std::unordered_map<std::string, int> m_special_nodes = {
        {"AND", 0},
        {"OR", 1},
        {"NOT", 2},
        {"F_AND", 3},
        {"F_OR", 4}
    }; #1#
//std::unordered_map<std::string, bool> m_node_printed;
std::map<fluent, int> m_fluent_to_id;
std::map<agent, int> m_agent_to_id;



/** Internal function to create a dataset for ML heuristics training. #1#
bool ML_dataset_creation(ML_Dataset_Params* ML_dataset);

/** Serial DFS dataset generation worker. #1#
bool dataset_DFS_serial(T& initial_state, int max_depth, action_set* actions, const std::string& goal_str, std::vector<std::string>& global_dataset, bool bisimulation);

/** DFS recursive worker to explore states for dataset generation. #1#
int dataset_DFS_worker(T& state, int depth, int max_depth, action_set* actions, const std::string& goal_str, std::vector<std::string>& local_dataset, bool bisimulation);

/** Formats a single row of the dataset CSV file. #1#
std::string format_row(T& state, int depth, int score, const std::string& goal_str);
                        */
